<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Vokabeltrainer</title>
<style>
    :root{
      --gap: 12px;
        
      --bg1:#f6f3ff;
      --bg2:#eef2ff;

      --card:#ffffff;
      --text:#0f172a;
      --muted:#64748b;

      --itemBg: rgba(251, 191, 36, 0.12) ;

      --line: rgba(15,23,42,.08);
      --shadow1: 0 10px 30px rgba(15,23,42,.08);
      --shadow2: 0 2px 12px rgba(15,23,42,.06);

      --r20: 20px;
      --r18: 18px;
      --r16: 16px;
      --r14: 14px;
      --r12: 12px;

      --primaryA:#2563eb;
      --primaryB:#7c3aed;

      --ctaA:#ea580c;
      --ctaB:#fbbf24;

      --okBorder:#bfe5c9;
      --okBg:#f2fbf4;
      --badBorder:#f0c0c6;
      --badBg:#fff7f8;
    }

    *{ box-sizing: border-box; }
    html, body { max-width: 100%; overflow-x: hidden; }

    body{
      margin:0;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1000px 500px at 50% 0%, var(--bg1), transparent 60%),
        radial-gradient(900px 600px at 40% 30%, var(--bg2), transparent 60%),
        #f7f7fb;
    }

    main{
      width:100%;
      max-width: 460px;
      margin: 22px auto;
      padding: 0 14px 22px;
      display:grid;
      gap: 14px;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--r20);
      box-shadow: var(--shadow2);
      padding: 14px;
    }

    .row{ display:flex; align-items:center; gap: var(--gap); flex-wrap: wrap; }
    .stack{ display:grid; gap: 10px; }

    .small{ font-size:12px; color: var(--muted); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .big{ font-size: 20px; font-weight: 900; line-height: 1.25; }
    .right{ margin-left:auto; }

    .appTitle{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      font-weight: 900;
      font-size: 22px;
      color:#5b21b6;
      margin: 4px 0 10px;
    }
    .spark{
      width:20px;height:20px;
      display:inline-grid; place-items:center;
      color:#7c3aed;
    }

    .sparkTop{
      align-self: flex-start;
      transform: translateY(-4px);
    }

    .sparkMid{
      align-self: center;
    }

    .sparkBot{
      align-self: flex-end;
      transform: translateY(4px);
    }
    
    /* Stats */
    .stats{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 12px;
    }
    .stat{
      background:#fff;
      border: 1px solid var(--line);
      border-radius: var(--r18);
      padding: 10px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }
    .stat .num{ font-size: 20px; font-weight: 900; line-height:1; }
    .stat .lbl{ font-size: 12px; color: var(--muted); margin-top: 4px; }

    /* Controls */
    button, select, input { font: inherit; }
    button{
      border: 1px solid rgba(15,23,42,.12);
      background: #fff;
      padding: 10px 12px;
      border-radius: var(--r16);
      cursor: pointer;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    button.danger{
      background:#fff;
      color:#b00020;
      border-color: rgba(176,0,32,.18);
    }
    .btnPrimary{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      border: 0;
      padding: 12px 14px;
      border-radius: var(--r18);
      color:#fff;
      font-weight: 900;
      background: linear-gradient(90deg, var(--ctaB), var(--ctaA));
      box-shadow: var(--shadow1);
    }

    /* List items */
    .item{
      display:flex;
      align-items:center;
      gap: 12px;
      padding: 12px 12px;
      border-radius: var(--r18);
      border: 1px solid var(--line);
      background: var(--itemBg);
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
      cursor: pointer;
    }
    .item:active{ transform: translateY(1px); }
    .ic{
      width: 32px; height: 32px;
      border-radius: 999px;
      display:grid; place-items:center;
      background: rgba(124,58,237,.12);
      color:#7c3aed;
      flex: 0 0 auto;
      font-weight: 900;
    }
    .txt{ display:grid; min-width: 0; }
    .txt strong{ font-size: 14px; }
    .txt span{ font-size: 12px; color: var(--muted); margin-top:2px; }
    .chev{ margin-left:auto; color: rgba(15,23,42,.35); font-size: 20px; }

    .sectionLbl{
      display:flex;
      align-items:center;
      gap: 8px;
      color: rgba(15,23,42,.75);
      font-weight: 900;
      font-size: 13px;
      margin-top: 10px;
      margin-bottom: 2px;
    }
    .mini{
      width:18px;height:18px;
      display:grid; place-items:center;
      color:#f59e0b;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.72);
      font-size: 12px;
      color: rgba(15,23,42,.85);
    }

    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      z-index: 999;
    }
    .overlay.open{ display:block; }
    .overlayPanel{
      position:absolute;
      inset: 10px;
      background: rgba(247,247,251,1);
      border-radius: var(--r20);
      padding: 10px;
      overflow:auto;
      border: 1px solid rgba(255,255,255,.55);
      box-shadow: var(--shadow1);
    }
    body.noscroll{ overflow:hidden; }

    .answer{
      padding: 12px;
      border: 1px dashed rgba(15,23,42,.18);
      border-radius: var(--r18);
      background: rgba(255,255,255,.75);
      margin-top: 10px;
    }
    .choices{ display:grid; gap: 8px; margin-top: 10px; }
    .choices button{ text-align:left; }

    .ok{ border-color: var(--okBorder) !important; background: var(--okBg) !important; }
    .bad{ border-color: var(--badBorder) !important; background: var(--badBg) !important; }

    .modal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display:none;
      z-index: 1000;
    }
    .modal.open{ display:block; }
    .modalPanel{
      position: absolute;
      left: 10px; right: 10px; bottom: 10px;
      background: #fff;
      border-radius: var(--r20);
      border: 1px solid var(--line);
      box-shadow: var(--shadow1);
      overflow: hidden;
      max-height: calc(100vh - 20px);
      display:flex;
      flex-direction: column;
    }
    .modalHead{
      padding: 12px 12px;
      display:flex;
      align-items:center;
      gap: 10px;
      border-bottom: 1px solid var(--line);
      background: rgba(255,255,255,.9);
    }
    .modalHead strong{ font-size: 14px; }
    .modalBody{
      padding: 12px;
      overflow:auto;
      display:grid;
      gap: 10px;
    }
    .modalFoot{
      padding: 12px;
      border-top: 1px solid var(--line);
      display:flex;
      gap: 10px;
      justify-content:flex-end;
      background: rgba(255,255,255,.9);
    }
    .field{
      display:grid;
      gap: 6px;
    }
    .field label{
      font-size: 12px;
      color: rgba(15,23,42,.8);
      font-weight: 800;
    }
    .field select, .field input{
      width:100%;
      padding: 10px;
      border-radius: var(--r16);
      border: 1px solid var(--line);
      background:#fff;
      outline:none;
    }

    /* Tags list */
    .tagList{
      display:grid;
      gap: 8px;
    }
    .tagRow{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid var(--line);
      border-radius: var(--r16);
      background: #fff;
    }
    .tagRow input[type="checkbox"]{ width:18px; height:18px; }
    .tagRow .name{ font-weight: 900; font-size: 13px; }
    .tagRow .date{ margin-left:auto; font-size: 12px; color: var(--muted); }

    /* CSV */
    details.csvBlock summary{
      list-style:none;
      cursor:pointer;
      user-select:none;
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      font-size: 13px;
      color: rgba(15,23,42,.85);
    }
    details.csvBlock summary::-webkit-details-marker{ display:none; }

    .tableWrap{
      overflow:auto;            /* horizontal + vertical inside */
      border: 1px solid var(--line);
      border-radius: var(--r18);
      background: #fff;
      max-height: 280px;
      margin-top: 10px;
    }
    table.csv{
      border-collapse: collapse;
      width: max-content;
      min-width: 100%;
    }
    table.csv th, table.csv td{
      border-bottom: 1px solid rgba(15,23,42,.06);
      padding: 7px 9px;
      white-space: nowrap;
      font-size: 11px;          /* deutlich kleiner */
      vertical-align: top;
    }
    table.csv th{
      position: sticky;
      top: 0;
      background: #fbfcfe;
      text-align: left;
      color: rgba(15,23,42,.7);
    }
    
    .vocabSearchRow{
      margin-top: 10px;
    }
    .vocabSearch{
      width: 100%;
      padding: 10px 12px;
      border-radius: var(--r16);
      border: 1px solid var(--line);
      background: #fff;
      outline: none;
    }
    .vocabSearch::placeholder{
      color: rgba(100,116,139,.9);
    }

    .vocabList{
      display:grid;
      gap: 10px;
      margin-top: 10px;
    }
    
    .vocabEntry{
      border: 1px solid var(--line);
      border-radius: var(--r18);
      background:#fff;
      overflow:hidden;
    }
    
    .vocabEntry summary{
      list-style:none;
      cursor:pointer;
      user-select:none;
      padding: 12px 12px;
      display:flex;
      align-items:center;
      gap: 10px;
    }
    
    .vocabEntry summary::-webkit-details-marker{ display:none; }
    
    .vocabWord{
      font-weight: 900;
      font-size: 15px;
      line-height: 1.2;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .vocabMeta{
      margin-left:auto;
      font-size: 12px;
      color: var(--muted);
      flex: 0 0 auto;
    }
    
    .vocabBody{
      padding: 0 12px 12px;
      display:grid;
      gap: 8px;
    }
    
    .vocabLine{
      font-size: 13px;
      color: rgba(15,23,42,.9);
      word-break: break-word;   /* bleibt in der Breite */
    }
    
    .vocabLine .k{
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
      margin-right: 6px;
    }
    
    /* Card 3: dunklere Variante des Primary Buttons */
    .btnLearn{
      background: linear-gradient(90deg, #f59e0b, #c2410c); /* etwas dunkler als CTA */
    }

    /* Card: Challenges Button (√§hnlich wie Learn) */
    .btnChallenge{
      background: linear-gradient(90deg, #fbbf24, #ea580c);
    }
    
    /* Challenge-History (letzte 3) */
    .challengeList{
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }
    
    .challengeRow{
      border: 1px solid var(--line);
      border-radius: var(--r16);
      background: rgba(255,255,255,.85);
      padding: 10px 10px;
      display: grid;
      gap: 4px;
    }
    
    .challengeRow .top{
      display:flex;
      align-items:center;
      gap: 8px;
    }
    
    .challengeRow .tag{
      font-weight: 900;
      font-size: 13px;
      overflow-wrap: anywhere;
    }
    
    .challengeRow .meta{
      margin-left:auto;
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
    }
    
    .challengeRow .sub{
      font-size: 12px;
      color: rgba(15,23,42,.72);
      line-height: 1.25;
    }

    /* Card 3: zuletzt gelernt (Pills) */
    .learnPills{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .learnPillBtn{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.85);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
    }
    
    .learnPillBtn:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    
    .learnList{
      display:grid;
      gap: 8px;
    }
    
    .learnRow{
      border: 1px solid var(--line);
      border-radius: var(--r16);
      background: #fff;
      padding: 10px 10px;
    
      display:grid;
      grid-template-columns: 1fr 1fr;
      column-gap: 12px;
    }
    
    .learnRow .f{
      font-weight: 900;
      font-size: 13px;
      line-height: 1.2;
      overflow-wrap: anywhere;
    }
    
    .learnRow .d{
      font-size: 12px;
      color: rgba(15,23,42,.75);
      overflow-wrap: anywhere;
    }

    .learnRow .ex{
      grid-column: 1 / -1;   /* √ºber beide Spalten */
      margin-top: 6px;
      font-size: 12px;
      color: rgba(15,23,42,.6);
      overflow-wrap: anywhere;
    }

    .learnRow .meta{
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btnOk{
      border: 1px solid rgba(34,197,94,.25);
      color: #065f46;
      font-weight: 900;
      background: linear-gradient(90deg,
        rgba(134,239,172,.75),
        rgba(187,247,208,.75)
      );
      box-shadow: 0 2px 10px rgba(34,197,94,.12);
    }
    
    .btnBad{
      border: 1px solid rgba(244,63,94,.22);
      color: #9f1239;
      font-weight: 900;
      background: linear-gradient(90deg,
        rgba(253,164,175,.75),
        rgba(254,205,211,.75)
      );
      box-shadow: 0 2px 10px rgba(244,63,94,.10);
    }
    
    .btnOk:disabled,
    .btnBad:disabled{
      opacity: .55;
      cursor: not-allowed;
      box-shadow: none;
    }

  </style>
</head>
<body>
<!-- Lern-Overlay -->
<div aria-hidden="true" class="overlay" id="learnOverlay">
<div class="overlayPanel">
<div class="row" style="margin-bottom: 10px;">
<strong>Lernen</strong>
<button disabled="" id="nextBtn2">N√§chste</button>
<button class="danger" disabled="" id="endBtn2">Beenden</button>
</div>
<div id="learnCardInner"></div>
</div>
</div>
<!-- Auswahl-Modal -->
<div aria-hidden="true" class="modal" id="modal">
<div aria-modal="true" class="modalPanel" role="dialog">
<div class="modalHead">
<strong id="modalTitle">Auswahl</strong>
<span class="right"></span>

</div>
<div class="modalBody" id="modalBody"></div>
<div class="modalFoot">
  <button id="modalCancelBtn">Abbrechen</button>
  <button class="btnPrimary" id="modalGoBtn" style="width:auto; padding:10px 12px;" disabled>Los geht's</button>
</div>
</div>
</div>
<main>
  <!-- Card 1: Nur √úberschrift -->
  <section class="card">
    <div class="appTitle">
      <span>Vokabeltrainer</span>
      <span class="spark sparkBot">‚ú¶</span>
      <span class="spark sparkMid">‚ú¶</span>
      <span class="spark sparkTop">‚ú¶</span>
    </div>
  </section>

  <!-- Card 2: Session (wie bisher, nur ohne √úberschrift) -->
  <section class="card">
    <button class="btnPrimary" disabled="" id="startBtn">Session starten</button>

    <div class="stack" style="margin-top:12px;">
      <div class="item" id="pickLang">
        <div class="ic" style="background: rgba(15,23,42,.06); color:#0f172a;">üåê</div>
        <div class="txt">
          <strong>Sprache</strong>
          <span id="labelLang">‚Äî</span>
        </div>
        <div class="chev">‚Ä∫</div>
      </div>

      <div class="item" id="pickDirection">
        <div class="ic" style="background: rgba(37,99,235,.12); color:#2563eb;">‚áÑ</div>
        <div class="txt">
          <strong>Richtung</strong>
          <span id="labelDirection">‚Äî</span>
        </div>
        <div class="chev">‚Ä∫</div>
      </div>

      <div class="item" id="pickMode">
        <div class="ic" style="background: rgba(124,58,237,.12); color:#7c3aed;">üß©</div>
        <div class="txt">
          <strong>Modus</strong>
          <span id="labelMode">‚Äî</span>
        </div>
        <div class="chev">‚Ä∫</div>
      </div>

      <div class="item" id="pickLimit">
        <div class="ic" style="background: rgba(245,158,11,.14); color:#b45309;">#</div>
        <div class="txt">
          <strong>Anzahl Fragen</strong>
          <span id="labelLimit">‚Äî</span>
        </div>
        <div class="chev">‚Ä∫</div>
      </div>

      <div class="item" id="pickLenient">
        <div class="ic" style="background: rgba(15,23,42,.06); color:#0f172a;">Aa</div>
        <div class="txt">
          <strong>Akzente & Gro√ü/klein ignorieren</strong>
          <span id="labelLenient">‚Äî</span>
        </div>
        <div class="chev">‚Ä∫</div>
      </div>

      <div class="item" id="pickTags">
        <div class="ic" style="background: rgba(124,58,237,.12); color:#7c3aed;">üè∑</div>
        <div class="txt">
          <strong>Units/Tags</strong>
          <span id="labelTags">‚Äî</span>
        </div>
        <div class="chev">‚Ä∫</div>
      </div>

      <div class="small">CSV: <span class="mono" id="csvLabel"></span></div>
    </div>
  </section>
  
  <section class="card" id="challengeCard">
    <button class="btnPrimary btnChallenge" disabled id="challengeStartBtn">Challenge starten</button>

    <!-- Letzte 3 Challenges -->
    <div class="sectionLbl" style="margin-top:12px;">
      <span class="mini">üïò</span>
      <span>Letzte Challenges</span>
    </div>

    <div id="challengeHistory" class="small" style="margin-top:8px;">
      Noch keine Challenges gespeichert.
    </div>
  </section>
    
  <section class="card" id="learnCard">
    <button class="btnPrimary btnLearn" disabled id="learnStartBtn">Vokabeln lernen</button>

    <div class="sectionLbl" style="margin-top:12px;">
      <span class="mini">üè∑</span>
      <span>Zuletzt gelernt</span>
    </div>

    <div id="recentLearnTags" class="learnPills" style="margin-top:8px;"></div>

    <div class="small" style="margin-top:10px;">
      Tipp: Klicke eine Unit/Tag an, um direkt zur Lerntabelle zu springen.
    </div>
  </section>

  <!-- Card 4: CSV bleibt -->
  <section class="card">
    <details class="csvBlock" id="csvDetails">
      <summary>
        <span>Vokabeltabelle anzeigen</span>
        <span class="right small" id="csvCountLabel"></span>
      </summary>

      <div class="vocabSearchRow">
        <input id="vocabSearch" class="vocabSearch" type="search" placeholder="Vokabel suchen (Fremdsprache oder Deutsch) ‚Ä¶">
      </div>

      <div id="vocabList" class="vocabList"></div>
      <div class="small" style="margin-top:8px;">
        Read-only Anzeige der CSV-Daten
      </div>
    </details>
  </section>
</main>
<script>
    function getListKey() {
      const p = new URLSearchParams(location.search);
      return (p.get("list") || "default").trim().toLowerCase();
    }
    const LIST_KEY = getListKey();
    const CSV_URL = `csv/vocab_${LIST_KEY}.csv`;
    const LS_LEARN_TAGS_KEY = `vocab_learn_last_tags_${LIST_KEY}`;

    let vocab = [];
    let APP_STATE = null;

    // =========================
    // STORAGE (Root per LIST_KEY)
    // =========================
    function stateKey(listKey) {
      return `vocab_state_${(listKey || "default").trim().toLowerCase()}`;
    }
    
    const SCHEMA_VERSION = 1;
    
    function nowTs() { return Date.now(); }
    
    function makeEmptyVocabState() {
      return {
        score: 0,
        seen: 0,
        correct: 0,
        wrong: 0,
        byMode: {
          FLASH: { seen: 0, correct: 0, wrong: 0 },
          MCQ:   { seen: 0, correct: 0, wrong: 0 },
          TYPE:  { seen: 0, correct: 0, wrong: 0 }
        },
        lastSeenAt: 0,
        decayStage: 0
      };
    }
    
    function makeDefaultRootState() {
      return {
        schemaVersion: SCHEMA_VERSION,
        updatedAt: 0,
        vocabById: {},
        challengesByTag: {},
        activeChallenge: null, 
        prefs: {
          selectedLang: "ALL",
          direction: "DE_TO_FOREIGN",
          mode: "FLASH",
          limitN: 0,
          lenient: false,
          selectedTags: [],
          recentLearnTags: [],
          lastBackupPromptAt: 0,
          lastExportAt: 0,
    
          // --- Streaks (neu) ---
          streak: {
            current: 0,
            best: 0,
            lastActiveDay: "",  // "YYYY-MM-DD"
            lastPopupDay: ""    // "YYYY-MM-DD"
          },
    
          // daily: { "YYYY-MM-DD": { uniqueIds: ["id1","id2", ...] } }
          daily: {}
        }
      };
    }
    
    function loadRootState() {
      const key = stateKey(LIST_KEY);
      const raw = localStorage.getItem(key);
      if (!raw) return makeDefaultRootState();
    
      try {
        const parsed = JSON.parse(raw);
    
        if (!parsed || typeof parsed !== "object") return makeDefaultRootState();
    
        const d = makeDefaultRootState();
        return {
          ...d,
          ...parsed,
          vocabById: parsed.vocabById && typeof parsed.vocabById === "object" ? parsed.vocabById : {},
          challengesByTag: parsed.challengesByTag && typeof parsed.challengesByTag === "object" ? parsed.challengesByTag : {},
          activeChallenge: (parsed.activeChallenge && typeof parsed.activeChallenge === "object")
            ? {
                id: String(parsed.activeChallenge.id || ""),
                tag: String(parsed.activeChallenge.tag || ""),
                targetN: Number(parsed.activeChallenge.targetN || 0),
                doneN: Number(parsed.activeChallenge.doneN || 0),
                correctN: Number(parsed.activeChallenge.correctN || 0),
                uniqueIds: Array.isArray(parsed.activeChallenge.uniqueIds)
                  ? parsed.activeChallenge.uniqueIds.map(x => String(x))
                  : [],
                startedAt: Number(parsed.activeChallenge.startedAt || 0),
                finishedAt: (parsed.activeChallenge.finishedAt == null) ? null : Number(parsed.activeChallenge.finishedAt),
              }
            : null,
          prefs: {
            ...d.prefs,
            ...(parsed.prefs || {}),
            streak: { ...d.prefs.streak, ...((parsed.prefs && parsed.prefs.streak) || {}) },
            daily:
              (parsed.prefs && typeof parsed.prefs.daily === "object" && parsed.prefs.daily)
                ? parsed.prefs.daily
                : {}
          }
        };
      } catch (e) {
        console.warn("[loadRootState] invalid JSON in localStorage -> reset", e);
        return makeDefaultRootState();
      }
    }
    
    function saveRootState(state) {
      state.updatedAt = nowTs();
      const key = stateKey(LIST_KEY);
      localStorage.setItem(key, JSON.stringify(state));
    }
    
    // =========================
    // CHALLENGES (State helpers)
    // =========================
    function makeChallengeId() {
      return "ch_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 7);
    }
    
    function ensureChallengeStore() {
      if (!APP_STATE) return;
      if (!APP_STATE.challengesByTag || typeof APP_STATE.challengesByTag !== "object") APP_STATE.challengesByTag = {};
      if (!("activeChallenge" in APP_STATE)) APP_STATE.activeChallenge = null;
    }
    
    function getActiveChallenge() {
      ensureChallengeStore();
      const c = APP_STATE?.activeChallenge;
      if (!c || typeof c !== "object") return null;
      if (!Array.isArray(c.uniqueIds)) c.uniqueIds = [];
      return c;
    }

    function startChallenge(tag, targetN) {
      if (!APP_STATE) return false;
      ensureChallengeStore();
    
      const t = String(tag || "").trim();
      const n = Math.max(1, Number(targetN || 0));
    
      if (!t || !Number.isFinite(n)) return false;
    
      const ch = {
        id: makeChallengeId(),
        tag: t,
        targetN: n,
        doneN: 0,
        correctN: 0,
        uniqueIds: [],
        startedAt: nowTs(),
        finishedAt: null
      };
    
      APP_STATE.activeChallenge = ch;
      saveRootState(APP_STATE);
    
      inChallenge = true; // du hast das Flag schon vorbereitet
      return true;
    }
    
    function recordChallengeAnswer(vocabId, isCorrect) {
      const ch = getActiveChallenge();
      if (!APP_STATE || !ch) return;
    
      const id = String(vocabId || "").trim();
      if (!id) return;
    
      // correctN z√§hlt jede korrekte Antwort (nicht unique)
      if (isCorrect) ch.correctN = (ch.correctN || 0) + 1;
    
      // doneN z√§hlt unique beantwortete Vokabeln
      if (!ch.uniqueIds.includes(id)) {
        ch.uniqueIds.push(id);
        ch.doneN = ch.uniqueIds.length;
      }
    
      // Ziel erreicht?
      if (ch.doneN >= ch.targetN) {
        finishChallenge("targetReached");
      } else {
        saveRootState(APP_STATE);
      }
    }
    
    function finishChallenge(reason = "") {
      const ch = getActiveChallenge();
      if (!APP_STATE || !ch) return false;
    
      ch.finishedAt = nowTs();
    
      const tag = ch.tag;
      if (!APP_STATE.challengesByTag[tag]) APP_STATE.challengesByTag[tag] = [];
      if (!Array.isArray(APP_STATE.challengesByTag[tag])) APP_STATE.challengesByTag[tag] = [];
    
      // neueste oben
      APP_STATE.challengesByTag[tag].unshift({ ...ch });
    
      // optional: History pro Tag begrenzen
      APP_STATE.challengesByTag[tag] = APP_STATE.challengesByTag[tag].slice(0, 50);
    
      APP_STATE.activeChallenge = null;
      saveRootState(APP_STATE);
    
      inChallenge = false;
      // ‚úÖ UI sofort beenden, sobald Challenge fertig
      if (inSession) {
        endSession();           // schlie√üt Overlay und setzt inSession=false
      }
      renderChallengeHistory(); // Home-Karte aktualisieren
      return true;
    }

    function renderChallengeHistory() {
      const host = document.getElementById("challengeHistory");
      if (!host) return;
    
      host.innerHTML = "";
    
      if (!APP_STATE || !APP_STATE.challengesByTag) {
        host.innerHTML = `<div class="small">Noch keine Challenges gespeichert.</div>`;
        return;
      }
    
      // Alle Challenges √ºber alle Tags einsammeln
      const all = [];
      for (const tag of Object.keys(APP_STATE.challengesByTag)) {
        const arr = APP_STATE.challengesByTag[tag];
        if (!Array.isArray(arr)) continue;
        for (const ch of arr) {
          all.push(ch);
        }
      }
    
      if (all.length === 0) {
        host.innerHTML = `<div class="small">Noch keine Challenges gespeichert.</div>`;
        return;
      }
    
      // Neueste zuerst
      all.sort((a, b) => (b.finishedAt || 0) - (a.finishedAt || 0));
    
      // Nur die letzten 3
      const last3 = all.slice(0, 3);
    
      last3.forEach(ch => {
        const row = document.createElement("div");
        row.className = "challengeRow";
    
        const top = document.createElement("div");
        top.className = "top";
    
        const tag = document.createElement("div");
        tag.className = "tag";
        tag.textContent = ch.tag || "‚Äî";
    
        const meta = document.createElement("div");
        meta.className = "meta";
        meta.textContent = `${ch.doneN}/${ch.targetN}`;
    
        top.appendChild(tag);
        top.appendChild(meta);
    
        const sub = document.createElement("div");
        sub.className = "sub";
        sub.textContent =
          `Richtig: ${ch.correctN || 0} ¬∑ ${new Date(ch.finishedAt).toLocaleDateString("de-DE")}`;
    
        row.appendChild(top);
        row.appendChild(sub);
    
        host.appendChild(row);
      });
    }
    
    function ensureVocabStatesFromCsv(state, vocabItems) {
      if (!state.vocabById) state.vocabById = {};
    
      for (const it of vocabItems) {
        const id = (it.id || "").toString().trim();
        if (!id) continue;
    
        if (!state.vocabById[id]) {
          state.vocabById[id] = makeEmptyVocabState();
        } else {
          const base = makeEmptyVocabState();
          const cur = state.vocabById[id] || {};
          state.vocabById[id] = {
            ...base,
            ...cur,
            byMode: {
              ...base.byMode,
              ...(cur.byMode || {}),
              FLASH: { ...base.byMode.FLASH, ...(cur.byMode?.FLASH || {}) },
              MCQ:   { ...base.byMode.MCQ,   ...(cur.byMode?.MCQ   || {}) },
              TYPE:  { ...base.byMode.TYPE,  ...(cur.byMode?.TYPE  || {}) }
            }
          };
          if (!Number.isFinite(state.vocabById[id].score) || state.vocabById[id].score < 0) {
            state.vocabById[id].score = 0;
          }
        }
      }
    }

    // =========================
    // SCORE UPDATE (ohne Decay)
    // =========================
    function clampScore(x) {
      return Math.max(0, Number.isFinite(x) ? x : 0);
    }
    
    function getVocabStateForId(id) {
      if (!APP_STATE) return null;
      if (!APP_STATE.vocabById) APP_STATE.vocabById = {};
      if (!APP_STATE.vocabById[id]) APP_STATE.vocabById[id] = makeEmptyVocabState();
      return APP_STATE.vocabById[id];
    }
    
    // =========================
    // STREAKS (Daily tracking + Popup)
    // =========================
    function pad2(n) { return String(n).padStart(2, "0"); }
    
    function dayKeyLocal(d = new Date()) {
      const y = d.getFullYear();
      const m = pad2(d.getMonth() + 1);
      const da = pad2(d.getDate());
      return `${y}-${m}-${da}`; // "YYYY-MM-DD"
    }
    
    function dayKeyFromKeyPlusDays(key, deltaDays) {
      // key: "YYYY-MM-DD"
      const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(key || "");
      if (!m) return "";
      const d = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
      d.setDate(d.getDate() + deltaDays);
      return dayKeyLocal(d);
    }
    
    function ensureStreakState() {
      if (!APP_STATE) return null;
      if (!APP_STATE.prefs) APP_STATE.prefs = {};
      if (!APP_STATE.prefs.streak) {
        APP_STATE.prefs.streak = { current: 0, best: 0, lastActiveDay: "", lastPopupDay: "" };
      } else {
        const s = APP_STATE.prefs.streak;
        if (!Number.isFinite(s.current)) s.current = 0;
        if (!Number.isFinite(s.best)) s.best = 0;
        if (typeof s.lastActiveDay !== "string") s.lastActiveDay = "";
        if (typeof s.lastPopupDay !== "string") s.lastPopupDay = "";
      }
      if (!APP_STATE.prefs.daily || typeof APP_STATE.prefs.daily !== "object") {
        APP_STATE.prefs.daily = {};
      }
      return APP_STATE.prefs.streak;
    }
    
    function ensureDailyEntry(dayKey) {
      const prefs = APP_STATE.prefs;
      if (!prefs.daily[dayKey]) prefs.daily[dayKey] = { uniqueIds: [] };
      if (!Array.isArray(prefs.daily[dayKey].uniqueIds)) prefs.daily[dayKey].uniqueIds = [];
      return prefs.daily[dayKey];
    }
    
    function countDaysOver50InCurrentStreak(todayKey, streakLen) {
      let over50 = 0;
      for (let i = 0; i < streakLen; i++) {
        const k = dayKeyFromKeyPlusDays(todayKey, -i);
        const entry = APP_STATE.prefs.daily[k];
        const n = entry && Array.isArray(entry.uniqueIds) ? entry.uniqueIds.length : 0;
        if (n > 50) over50++;
      }
      return over50;
    }

    function startMiniFireworks(canvas, durationMs = 1800) {
      const ctx = canvas.getContext("2d");
      if (!ctx) return () => {};
    
      const parts = [];
      const rand = (a, b) => a + Math.random() * (b - a);
    
      function resize() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
    
        const w = Math.max(1, Math.floor(rect.width));
        const h = Math.max(1, Math.floor(rect.height));
    
        // Canvas in echten Pixeln
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
    
        // Zeichnen in CSS-Pixeln
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    
      function spawnBurst() {
        const r = canvas.getBoundingClientRect();
        const x = rand(r.width * 0.2, r.width * 0.8);
        const y = rand(r.height * 0.15, r.height * 0.55);
        const n = Math.floor(rand(20, 32));
    
        for (let i = 0; i < n; i++) {
          const ang = rand(0, Math.PI * 2);
          const sp = rand(1.6, 3.8);
          parts.push({
            x, y,
            vx: Math.cos(ang) * sp,
            vy: Math.sin(ang) * sp,
            life: rand(26, 46),
            r: rand(1.2, 2.6),
            col: `hsl(${Math.floor(rand(0, 360))}, 90%, 60%)`
          });
        }
      }
    
      let raf = 0;
      let running = true;
      const start = Date.now();
      let lastBurstAt = 0;
    
      function step() {
        if (!running) return;
    
        const now = Date.now();
        const t = now - start;
    
        // Canvas ggf. nachziehen (Modal kann w√§hrenddessen layouten)
        resize();
    
        const r = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, r.width, r.height);
    
        if (t - lastBurstAt > rand(160, 280)) {
          spawnBurst();
          lastBurstAt = t;
        }
    
        ctx.globalCompositeOperation = "lighter";
    
        for (let i = parts.length - 1; i >= 0; i--) {
          const p = parts[i];
    
          p.x += p.vx;
          p.y += p.vy;
    
          p.vy += 0.06;
          p.vx *= 0.985;
          p.vy *= 0.985;
    
          p.life -= 1;
    
          const alpha = Math.max(0, Math.min(1, p.life / 46));
          ctx.globalAlpha = alpha;
          ctx.beginPath();
          ctx.fillStyle = p.col;
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
    
          if (p.life <= 0 || p.x < -20 || p.x > r.width + 20 || p.y > r.height + 60) {
            parts.splice(i, 1);
          }
        }
    
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
    
        if (t >= durationMs) {
          running = false;
          ctx.clearRect(0, 0, r.width, r.height);
          return;
        }
    
        raf = requestAnimationFrame(step);
      }
    
      const onResize = () => resize();
      window.addEventListener("resize", onResize);
    
      // Wichtig: Start 1 Frame verz√∂gern, damit Modal layouted
      raf = requestAnimationFrame(step);
    
      return () => {
        running = false;
        if (raf) cancelAnimationFrame(raf);
        window.removeEventListener("resize", onResize);
        try {
          const r = canvas.getBoundingClientRect();
          ctx.clearRect(0, 0, r.width, r.height);
        } catch {}
      };
    }

    function showStreakPopup(streakDays, daysOver50) {
      openModal(
        "üî• Streak!",
        (body) => {
          if ($("modalGoBtn")) {
            $("modalGoBtn").disabled = false;
            $("modalGoBtn").textContent = "OK";
          }
          if ($("modalCancelBtn")) $("modalCancelBtn").style.display = "none";
    
          // Canvas f√ºr Feuerwerk
          const canvas = document.createElement("canvas");
          canvas.style.width = "100%";
          canvas.style.height = "120px";
          canvas.style.borderRadius = "16px";
          canvas.style.border = "1px solid rgba(15,23,42,.08)";
          canvas.style.background = "linear-gradient(180deg, rgba(255,255,255,.9), rgba(255,255,255,.75))";
          body.appendChild(canvas);
    
          const msg = document.createElement("div");
          msg.className = "big";
          msg.style.fontSize = "18px";
          msg.style.lineHeight = "1.3";
          msg.style.marginTop = "10px";
          msg.textContent = `Du hast jetzt schon ${streakDays} Tage am St√ºck gelernt.`;
          body.appendChild(msg);
    
          const sub = document.createElement("div");
          sub.className = "small";
          sub.style.marginTop = "8px";
          sub.textContent = `Besonders: Davon hast du an ${daysOver50} Tagen mehr als 50 Vokabeln gelernt.`;
          body.appendChild(sub);
    
          // Feuerwerk starten (automatisch stopp nach ~1.8s)
          const stop = startMiniFireworks(canvas, 1800);
    
          // Sicherheits-stop, falls das Modal fr√ºher geschlossen wird (einfacher: einmalig nach 2s)
          setTimeout(() => stop(), 2000);
        },
        null
      );
    }
    
    function recordLearningAndMaybeShowStreak(vocabId) {
      const s = ensureStreakState();
      if (!s) return;
    
      const today = dayKeyLocal(new Date());
      const yesterday = dayKeyFromKeyPlusDays(today, -1);
    
      // 1) Daily uniqueIds pflegen
      const entry = ensureDailyEntry(today);
      const ids = entry.uniqueIds;
    
      // unique add
      if (!ids.includes(vocabId)) ids.push(vocabId);
    
      // 2) Streak nur beim ersten "Lernen" des Tages updaten + ggf. Popup zeigen
      // (d.h. nur wenn lastActiveDay noch nicht today war)
      if (s.lastActiveDay !== today) {
        const continues = (s.lastActiveDay === yesterday);
    
        s.current = continues ? (Number(s.current || 0) + 1) : 1;
        s.best = Math.max(Number(s.best || 0), s.current);
        s.lastActiveDay = today;
    
        // Popup nur einmal pro Tag und erst ab 2 Tagen Streak
        if (s.current >= 2 && s.lastPopupDay !== today) {
          const over50 = countDaysOver50InCurrentStreak(today, s.current);
          s.lastPopupDay = today;
    
          saveRootState(APP_STATE); // sicherstellen, dass Popup-Status persistiert ist
          showStreakPopup(s.current, over50);
        }
      }
    }
    
    function maybeShowStreakPopupIfDue(reason = "") {
      const s = ensureStreakState();
      if (!s) return;
    
      const today = dayKeyLocal(new Date());
    
      // Popup nur, wenn heute schon "aktiv" war (d.h. first learn today ist passiert)
      // und das Popup heute noch nicht gezeigt wurde.
      if (s.lastActiveDay !== today) return;
      if (s.current < 2) return;
      if (s.lastPopupDay === today) return;
    
      const over50 = countDaysOver50InCurrentStreak(today, s.current);
      s.lastPopupDay = today;
    
      saveRootState(APP_STATE);
      console.log("[streak] popup due on", reason);
      showStreakPopup(s.current, over50);
    }
    
    function applyAnswerScore(id, mode, isCorrect) {
      const s = getVocabStateForId(id);
      if (!s) return;
    
      const m = (mode || "FLASH").toUpperCase();
    
      let delta = 0;
      if (m === "MCQ")  delta = isCorrect ? 0.5 : -0.25;
      if (m === "TYPE") delta = isCorrect ? 2.0 : -1.0;
      if (m === "FLASH") delta = isCorrect ? 1.0 : -0.5;
    
      s.score = clampScore((s.score || 0) + delta);
    
      s.seen = (s.seen || 0) + 1;
      if (isCorrect) s.correct = (s.correct || 0) + 1;
      else s.wrong = (s.wrong || 0) + 1;
    
      if (!s.byMode) s.byMode = makeEmptyVocabState().byMode;
      if (!s.byMode[m]) s.byMode[m] = { seen: 0, correct: 0, wrong: 0 };
    
      s.byMode[m].seen = (s.byMode[m].seen || 0) + 1;
      if (isCorrect) s.byMode[m].correct = (s.byMode[m].correct || 0) + 1;
      else s.byMode[m].wrong = (s.byMode[m].wrong || 0) + 1;
    
      s.lastSeenAt = Date.now();
      s.decayStage = 0;
    
      // --- Streak-Tracking: beim ersten Lernen des Tages Popup am Anfang ---
      // (Counts: unique IDs pro Tag, Aktivit√§t z√§hlt ab erster beantworteter Vokabel)
      if (APP_STATE && APP_STATE.prefs) {
        recordLearningAndMaybeShowStreak(id);
      }
    
      if (APP_STATE) saveRootState(APP_STATE);
    }

    const DAY = 24 * 60 * 60 * 1000;
    
    function applyDecayIfNeededForId(id) {
      const s = getVocabStateForId(id);
      if (!s) return;
    
      const now = Date.now();
      const last = Number(s.lastSeenAt || 0);
    
      if (!last || last <= 0) return;
    
      const age = now - last;
    
      if (age >= 90 * DAY) {
        if ((s.score || 0) !== 0 || (s.decayStage || 0) !== 4) {
          s.score = 0;
          s.decayStage = 4;
          saveRootState(APP_STATE);
        }
        return;
      }
    
      let stage = Number(s.decayStage || 0);
    
      if (age >= 42 * DAY && stage < 3) {
        s.score = clampScore((s.score || 0) - 0.75);
        stage = 3;
      }
    
      if (age >= 21 * DAY && stage < 2) {
        s.score = clampScore((s.score || 0) - 0.5);
        stage = 2;
      }
    
      if (age >= 7 * DAY && stage < 1) {
        s.score = clampScore((s.score || 0) - 0.25);
        stage = 1;
      }
    
      if (stage !== (s.decayStage || 0)) {
        s.decayStage = stage;
        saveRootState(APP_STATE);
      }
    }
    
    function getCategoryFromScore(score) {
      const s = Number(score) || 0;
      if (s <= 1.5) return 1;
      if (s <= 3.5) return 2;
      return 3;
    }
    
    function countCats(items) {
      const out = { total: 0, cat1: 0, cat2: 0, cat3: 0 };
      out.total = items.length;
    
      for (const it of items) {
        const st = getVocabStateForId(it.id);
        const sc = st ? st.score : 0;
        const cat = getCategoryFromScore(sc);
    
        if (cat === 1) out.cat1++;
        else if (cat === 2) out.cat2++;
        else out.cat3++;
      }
      return out;
    }

    function weightedShuffleForSmallPool(items) {
      // Gewichtung nach Kategorie
      function weight(it) {
        const st = getVocabStateForId(it.id);
        const sc = st ? st.score : 0;
        const cat = getCategoryFromScore(sc);
        if (cat === 1) return 3;
        if (cat === 2) return 2;
        return 1;
      }
    
      // jedem Item eine Zufallszahl mit Gewicht geben
      return items
        .map(it => ({ it, key: Math.random() ** (1 / weight(it)) }))
        .sort((a, b) => b.key - a.key)
        .map(x => x.it);
    }

    let selectedLang = "ALL";
    let direction = "DE_TO_FOREIGN";
    let mode = "FLASH";
    let limitN = 0;
    let lenient = false;
    let selectedTags = new Set();
    
    let session = [];
    let idx = 0;
    let score = 0;
    
    let inSession = false;
    let inChallenge = false; // (f√ºr sp√§ter) ‚Äì blockiert Reload w√§hrend Challenge
    
    let currentDirForQuestion = "DE_TO_FOREIGN";
    let vocabSearchQuery = "";
    
    const $ = (id) => document.getElementById(id);

    function parseISODate(s) {
      if (!s) return null;
      const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s.trim());
      if (!m) return null;
      const d = new Date(`${m[1]}-${m[2]}-${m[3]}T00:00:00`);
      return isNaN(d.getTime()) ? null : d;
    }

    function normalize(str, isLenient=true) {
      if (!str) return "";
      let s = str.trim();
      if (isLenient) {
        s = s.toLowerCase();
        s = s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      }
      s = s.replace(/\s+/g, " ");
      return s;
    }

    function parseTags(tags) {
      return (tags || "")
        .split(";")
        .map(t => t.trim())
        .filter(Boolean);
    }

    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // -------------------------
    // CSV parser
    // -------------------------
    function fromCsv(text) {
      const rows = [];
      let i = 0, field = "", row = [], inQuotes = false;

      function pushField() { row.push(field); field = ""; }
      function pushRow() { rows.push(row); row = []; }

      while (i < text.length) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i+1] === '"') { field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          } else { field += c; i++; continue; }
        } else {
          if (c === '"') { inQuotes = true; i++; continue; }
          if (c === ',') { pushField(); i++; continue; }
          if (c === '\n') { pushField(); pushRow(); i++; continue; }
          if (c === '\r') { i++; continue; }
          field += c; i++; continue;
        }
      }
      pushField();
      if (row.length > 1 || (row[0] ?? "").trim() !== "") pushRow();
      if (rows.length === 0) return [];

      const header = rows[0].map(h => (h ?? "").trim().toLowerCase());
      const dataRows = rows.slice(1);
      const ix = (name) => header.indexOf(name);

      const idxMap = {
        id: ix("id"),
        added: ix("added"),
        de: ix("de"),
        foreign: ix("foreign"),
        lang: ix("lang"),
        tags: ix("tags"),
        example: ix("example")
      };

      const out = [];
      for (const r of dataRows) {
        const get = (k) => {
          const j = idxMap[k];
          return j >= 0 ? ((r[j] ?? "").toString().trim()) : "";
        };

        out.push({
          id: get("id"),
          added: get("added"),
          de: get("de"),
          foreign: get("foreign"),
          lang: (get("lang") || "EN").toUpperCase(),
          tags: get("tags"),
          example: get("example")
        });
      }
      return out;
    }

    // -------------------------
    // Tags recency map + sorted list
    // -------------------------
    function computeTagRecency() {
      const map = new Map();
      for (const v of vocab) {
        const d = parseISODate(v.added) || new Date(0);
        for (const t of parseTags(v.tags)) {
          const prev = map.get(t);
          if (!prev || d > prev) map.set(t, d);
        }
      }
      return map;
    }

    function tagDateStr(d) {
      if (!d) return "";
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const da = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }

    function getAllLangs() {
      return [...new Set(vocab.map(v => (v.lang || "EN").toUpperCase()).filter(Boolean))]
        .sort((a,b)=>a.localeCompare(b, "de"));
    }

    // -------------------------
    // Build session
    // -------------------------
    function buildSession() {
      let pool = vocab.slice();

      if (selectedLang !== "ALL") {
        pool = pool.filter(v => (v.lang || "").toUpperCase() === selectedLang);
      }

      if (selectedTags.size > 0) {
        pool = pool.filter(v => parseTags(v.tags).some(t => selectedTags.has(t)));
      }

      pool = pool.filter(v => (v.de || "").trim() && (v.foreign || "").trim());
      const sessionSize = (limitN === 0)
        ? pool.length
        : Math.min(limitN, pool.length);
      for (const it of pool) {
        applyDecayIfNeededForId(it.id);
      } 
      if (sessionSize > 0 && sessionSize < 7) {
        const mixed = weightedShuffleForSmallPool(pool);
        session = mixed.slice(0, sessionSize);
        idx = 0;
        score = 0;
        inSession = session.length > 0;
       
        console.log("[Small pool weighted mix]", countCats(session));
        return inSession;
      }
      const poolCats = countCats(pool);
      console.log("[Pool categories]", poolCats);
    
      const c1 = [];
      const c2 = [];
      const c3 = [];
    
      for (const it of pool) {
        applyDecayIfNeededForId(it.id);
        const st = getVocabStateForId(it.id);
        const sc = st ? st.score : 0;
        const cat = getCategoryFromScore(sc);
        if (cat === 1) c1.push(it);
        else if (cat === 2) c2.push(it);
        else c3.push(it);
      }
    
      shuffle(c1); shuffle(c2); shuffle(c3);
    
      function computeTargets(n) {
        if (n <= 0) return { t1: 0, t2: 0, t3: 0 };
    
        const w1 = 4, w2 = 3, w3 = 2;
        const sum = w1 + w2 + w3;
    
        let t1 = Math.floor(n * w1 / sum);
        let t2 = Math.floor(n * w2 / sum);
        let t3 = Math.floor(n * w3 / sum);
    
        let used = t1 + t2 + t3;
        const remainders = [
          { k: 1, r: n * w1 / sum - t1 },
          { k: 2, r: n * w2 / sum - t2 },
          { k: 3, r: n * w3 / sum - t3 }
        ].sort((a,b) => b.r - a.r);
    
        let i = 0;
        while (used < n) {
          const k = remainders[i % remainders.length].k;
          if (k === 1) t1++;
          else if (k === 2) t2++;
          else t3++;
          used++;
          i++;
        }
    
        return { t1, t2, t3 };
      }
    
      const { t1, t2, t3 } = computeTargets(sessionSize);
    
      const picked = [];
      function take(arr, n) {
        const out = arr.slice(0, Math.max(0, n));
        arr.splice(0, out.length);
        return out;
      }
    
      picked.push(...take(c1, t1));
      picked.push(...take(c2, t2));
      picked.push(...take(c3, t3));
    
      function fillToSize() {
        while (picked.length < sessionSize) {
          if (c1.length) picked.push(c1.shift());
          else if (c2.length) picked.push(c2.shift());
          else if (c3.length) picked.push(c3.shift());
          else break; // nichts mehr da
        }
      }
      fillToSize();
    
      if (picked.length > sessionSize) picked.length = sessionSize;
    
      shuffle(picked);
    
      const pickedCats = countCats(picked);
        
      const note = [];
      if (pickedCats.cat1 < t1) note.push(`cat1 fehlen ${t1 - pickedCats.cat1}`);
      if (pickedCats.cat2 < t2) note.push(`cat2 fehlen ${t2 - pickedCats.cat2}`);
      if (pickedCats.cat3 < t3) note.push(`cat3 fehlen ${t3 - pickedCats.cat3}`);
        
      console.log("[Session targets]", {
        sessionSize,
        targets: { cat1: t1, cat2: t2, cat3: t3 }
      });
      console.log("[Session picked]", pickedCats);
      if (note.length) console.log("[Auto-fill notice]", note.join(" ¬∑ "));

      session = picked;
      idx = 0;
      score = 0;
      inSession = session.length > 0;

      return inSession;
    }

    function currentItem() { return session[idx]; }

    function qText(item) {
      const dir = currentDirForQuestion;
      return dir === "DE_TO_FOREIGN" ? item.de : item.foreign;
    }
    function aText(item) {
      const dir = currentDirForQuestion;
      return dir === "DE_TO_FOREIGN" ? item.foreign : item.de;
    }

    // -------------------------
    // Learn UI
    // -------------------------
    function renderExampleUnder(targetEl, item) {
      const ex = (item.example || "").trim();
      if (!ex) return;
      const div = document.createElement("div");
      div.className = "small";
      div.style.marginTop = "6px";
      div.textContent = `Beispiel: ${ex}`;
      targetEl.appendChild(div);
    }

    function renderLearnInner(container) {
      container.innerHTML = "";

      if (!inSession) {
        container.innerHTML = `<div class="small">Keine aktive Session. Tippe auf ‚ÄûSession starten‚Äú.</div>`;
        return;
      }

      const item = currentItem();
        
      const nextBtn = $("nextBtn2");
      if (nextBtn) nextBtn.disabled = true;
        
      // direction logic per question
      currentDirForQuestion = (direction === "BOTH")
        ? (Math.random() < 0.5 ? "DE_TO_FOREIGN" : "FOREIGN_TO_DE")
        : direction;

      const head = document.createElement("div");
      head.innerHTML = `
        <div class="small" style="margin-bottom:8px;">
          Sprache: <span class="mono">${(item.lang||"").toUpperCase()}</span>
          ¬∑ Tags: <span class="mono">${item.tags||"-"}</span>
          ¬∑ Added: <span class="mono">${item.added||"-"}</span>
        </div>
        <div class="big">${qText(item)}</div>
      `;
      container.appendChild(head);

      if (mode === "FLASH") {
        const ans = document.createElement("div");
        ans.className = "answer";
        ans.innerHTML = `
          <div class="small">Klicke ‚ÄûAufdecken‚Äú, dann bewerte dich selbst.</div>
          <div class="row" style="margin-top:10px;">
            <button id="revealBtn">Aufdecken</button>
            <span class="right"></span>
          </div>
          <div id="revealArea" style="margin-top:10px; display:none;"></div>
          <div class="row" style="margin-top:10px;">
            <button id="selfOkBtn" class="btnOk" style="width:auto; padding:10px 12px;" disabled>Richtig</button>
            <button id="selfBadBtn" class="btnBad" style="width:auto; padding:10px 12px;" disabled>Falsch</button>
          </div>
        `;
        container.appendChild(ans);

        $("revealBtn").onclick = () => {
          const revealArea = $("revealArea");
          revealArea.style.display = "block";
          revealArea.innerHTML = "";

          const sol = document.createElement("div");
          sol.className = "big";
          sol.textContent = aText(item);
          revealArea.appendChild(sol);

          renderExampleUnder(revealArea, item);

          $("selfOkBtn").disabled = false;
          $("selfBadBtn").disabled = false;
        };

        $("selfOkBtn").onclick = () => { 
          score++;
          applyAnswerScore(item.id, "FLASH", true);
          if (inChallenge) recordChallengeAnswer(item.id, true);
          next();
        };
        
        $("selfBadBtn").onclick = () => { 
          applyAnswerScore(item.id, "FLASH", false);
          if (inChallenge) recordChallengeAnswer(item.id, false);
          next();
        };

      } else if (mode === "MCQ") {
        const allSameLang = vocab.filter(v => (v.lang||"").toUpperCase() === (item.lang||"").toUpperCase());
        const correct = aText(item);

        const distractors = shuffle(
          allSameLang
            .filter(v => v !== item)
            .map(v => aText(v))
            .filter(t => normalize(t, true) !== normalize(correct, true))
        ).slice(0, 3);

        const choices = shuffle([correct, ...distractors]);

        const wrap = document.createElement("div");
        wrap.className = "choices";

        choices.forEach(ch => {
          const b = document.createElement("button");
          b.textContent = ch;
          b.onclick = () => {
            const ok = normalize(ch, true) === normalize(correct, true);
            if (ok) { b.classList.add("ok"); score++; }
            else { b.classList.add("bad"); }

            applyAnswerScore(item.id, "MCQ", ok);
            if (inChallenge) recordChallengeAnswer(item.id, ok);

            [...wrap.querySelectorAll("button")].forEach(x => x.disabled = true);

            const reveal = document.createElement("div");
            reveal.className = "small";
            reveal.style.marginTop = "10px";

            if (ok) reveal.innerHTML = `<span class="pill ok">‚úî richtig</span>`;
            else reveal.innerHTML = `<span class="pill bad">‚úò falsch</span> <span class="mono">Richtig: ${correct}</span>`;

            renderExampleUnder(reveal, item);
            container.appendChild(reveal);
              
            $("nextBtn2").disabled = false;
          };
          wrap.appendChild(b);
        });

        container.appendChild(wrap);

        const hint = document.createElement("div");
        hint.className = "small";
        hint.style.marginTop = "8px";
        hint.textContent = "Danach auf ‚ÄûN√§chste‚Äú tippen.";
        container.appendChild(hint);

      } else if (mode === "TYPE") {
        const correct = aText(item);

        const area = document.createElement("div");
        area.className = "answer";
        area.innerHTML = `
          <div class="field">
            <label>Deine Antwort</label>
            <input id="typeInput" placeholder="Antwort eintippen" />
          </div>
          <div class="row">
            <button id="checkBtn" class="btnPrimary" style="width:auto; padding:10px 12px;">Pr√ºfen</button>
            <button id="showBtn">L√∂sung zeigen</button>
          </div>
          <div id="feedback" class="small" style="margin-top:10px;"></div>
        `;
        container.appendChild(area);
        $("typeInput").focus();
          
        let typeAnswered = false;

        const markAnswered = () => {
          typeAnswered = true;
          $("checkBtn").disabled = true;
          $("typeInput").disabled = true;
          $("nextBtn2").disabled = false;
        };
        
        const renderSolutionWithExample = (html) => {
          const fb = $("feedback");
          fb.innerHTML = html;
          renderExampleUnder(fb, item);
        };
        
        $("checkBtn").onclick = () => {
          if (typeAnswered) return;
        
          const user = $("typeInput").value;
          const ok = normalize(user, lenient) === normalize(correct, lenient);
        
          if (ok) score++;
          applyAnswerScore(item.id, "TYPE", ok);
          if (inChallenge) recordChallengeAnswer(item.id, ok);
            
          renderSolutionWithExample(
            ok
              ? `<span class="pill ok">‚úî richtig</span>`
              : `<span class="pill bad">‚úò falsch</span> <span class="mono">Richtig: ${correct}</span>`
          );
        
          markAnswered();
        };
        
        $("showBtn").onclick = () => {
          if (typeAnswered) return;
        
          renderSolutionWithExample(`<span class="mono">L√∂sung: ${correct}</span>`);
          applyAnswerScore(item.id, "TYPE", false);
          if (inChallenge) recordChallengeAnswer(item.id, false);
          markAnswered();
        };

        const hint = document.createElement("div");
        hint.className = "small";
        hint.style.marginTop = "8px";
        hint.textContent = "Danach auf ‚ÄûN√§chste‚Äú tippen.";
        container.appendChild(hint);
      }
    }

    function openOverlay() {
      $("learnOverlay").classList.add("open");
      $("learnOverlay").setAttribute("aria-hidden", "false");
      document.body.classList.add("noscroll");
      syncOverlayButtons();
      renderLearnInner($("learnCardInner"));
      $("learnOverlay").querySelector(".overlayPanel").scrollTop = 0;
    }

    function closeOverlay() {
      $("learnOverlay").classList.remove("open");
      $("learnOverlay").setAttribute("aria-hidden", "true");
      document.body.classList.remove("noscroll");
    }

    function syncOverlayButtons() {
      const isFlash = (mode === "FLASH");
    
      $("endBtn2").disabled = !inSession;
    
      $("nextBtn2").style.display = isFlash ? "none" : "";
    }

    function next() {
      if (!inSession) return;
    
      if (idx < session.length - 1) {
        idx++;
      } else {
        inSession = false;
      }
    
      syncOverlayButtons();
      renderLearnInner($("learnCardInner"));
    }

    function endSession() {
      // ‚úÖ Wenn Challenge l√§uft: verwerfen (nicht speichern)
      if (inChallenge && APP_STATE) {
        APP_STATE.activeChallenge = null;
        saveRootState(APP_STATE);
        inChallenge = false;
      }
    
      inSession = false;
      session = [];
      idx = 0;
      renderLearnInner($("learnCardInner"));
      syncOverlayButtons();
      closeOverlay();
    }

    // -------------------------
    // CSV table
    // -------------------------
    function renderCsvTable() {
      const host = $("vocabList");
      if (!host) return;
      host.innerHTML = "";
    
      // Alphabetisch nach Fremdsprache
      const rows = vocab.slice().sort((a, b) => {
        const fa = (a.foreign || "").trim();
        const fb = (b.foreign || "").trim();
        return fa.localeCompare(fb, "de", { sensitivity: "base" });
      });

      const q = normalize(vocabSearchQuery, true);
      const filtered = q
        ? rows.filter(it => {
            const f = normalize(it.foreign || "", true);
            const d = normalize(it.de || "", true);
            return f.includes(q) || d.includes(q);
          })
        : rows;
        
      for (const it of filtered) {
        const d = document.createElement("details");
        d.className = "vocabEntry";
    
        const s = document.createElement("summary");
    
        const w = document.createElement("div");
        w.className = "vocabWord";
        w.textContent = (it.foreign || "").trim() || "‚Äî";
    
        const m = document.createElement("div");
        m.className = "vocabMeta";
        // optional: Sprache anzeigen
        m.textContent = (it.lang || "").toUpperCase();
    
        s.appendChild(w);
        s.appendChild(m);
    
        const body = document.createElement("div");
        body.className = "vocabBody";
    
        const lineDe = document.createElement("div");
        lineDe.className = "vocabLine";
        lineDe.innerHTML = `<span class="k">DE:</span>${(it.de || "‚Äî")}`;
    
        const lineEx = document.createElement("div");
        lineEx.className = "vocabLine";
        const ex = (it.example || "").trim();
        lineEx.innerHTML = ex ? `<span class="k">Beispiel:</span>${ex}` : `<span class="k">Beispiel:</span>‚Äî`;
    
        const lineTags = document.createElement("div");
        lineTags.className = "vocabLine";
        const tags = (it.tags || "").trim();
        lineTags.innerHTML = tags ? `<span class="k">Tags:</span>${tags}` : `<span class="k">Tags:</span>‚Äî`;
    
        body.appendChild(lineDe);
        body.appendChild(lineEx);
        body.appendChild(lineTags);
        const lineAdded = document.createElement("div");
        lineAdded.className = "vocabLine";
        const added = (it.added || "").trim();
        lineAdded.innerHTML = added ? `<span class="k">Added:</span>${added}` : `<span class="k">Added:</span>‚Äî`;

        body.appendChild(lineAdded);
    
        d.appendChild(s);
        d.appendChild(body);
    
        host.appendChild(d);
      }
    
      $("csvCountLabel").textContent = `${filtered.length} / ${vocab.length}`;
    }

    // -------------------------
    // Home labels
    // -------------------------
    function directionLabel(v){
      if (v === "DE_TO_FOREIGN") return "Deutsch ‚Üí Fremdsprache";
      if (v === "FOREIGN_TO_DE") return "Fremdsprache ‚Üí Deutsch";
      return "Beide Richtungen (gemischt)";
    }
    function modeLabel(v){
      if (v === "FLASH") return "Karteikarten (richtig/falsch)";
      if (v === "MCQ") return "Multiple Choice";
      return "Eingabe";
    }

    function updateLabels() {
      $("labelLang").textContent = (selectedLang === "ALL") ? "Alle Sprachen" : selectedLang;
      $("labelDirection").textContent = directionLabel(direction);
      $("labelMode").textContent = modeLabel(mode);
      $("labelLimit").textContent = (limitN === 0) ? "Alle" : String(limitN);
      $("labelLenient").textContent = lenient ? "an (ignoriert Gro√ü/Klein + Akzente)" : "aus";

      if (selectedTags.size === 0) $("labelTags").textContent = "Alle";
      else if (selectedTags.size === 1) $("labelTags").textContent = [...selectedTags][0];
      else $("labelTags").textContent = `${selectedTags.size} ausgew√§hlt`;

    }

    // -------------------------
    // Modal helpers
    // -------------------------
    let modalOnOk = null;
    
    function openModal(title, buildBodyFn, onOkFn) {
      $("modalTitle").textContent = title;
    
      // ‚úÖ Reset IMMER zuerst (damit Spezial-Modals danach √ºberschreiben k√∂nnen)
      if ($("modalCancelBtn")) $("modalCancelBtn").style.display = "";
      if ($("modalGoBtn")) {
        $("modalGoBtn").textContent = "Los geht's";
        $("modalGoBtn").disabled = true;
      }
    
      const body = $("modalBody");
      body.innerHTML = "";
    
      // Jetzt darf das Modal seinen Spezialzustand setzen
      buildBodyFn(body);
    
      modalOnOk = onOkFn || null;
    
      $("modal").classList.add("open");
      $("modal").setAttribute("aria-hidden", "false");
      document.body.classList.add("noscroll");
    }

    function closeModal(trigger) {
      $("modal").classList.remove("open");
      $("modal").setAttribute("aria-hidden", "true");
      document.body.classList.remove("noscroll");

      if (trigger === "ok" && typeof modalOnOk === "function") modalOnOk();

      modalOnOk = null;
    }

    // -------------------------
    // Option modals
    // -------------------------
    function openLangModal() {
      const langs = getAllLangs();
      let temp = selectedLang;

      openModal(
        "Sprache",
        (body) => {
          $("modalGoBtn").disabled = false;
          $("modalGoBtn").textContent = "OK";
          const wrap = document.createElement("div");
          wrap.className = "field";
          wrap.innerHTML = `<label>Sprache ausw√§hlen</label>`;
          const sel = document.createElement("select");

          const oAll = document.createElement("option");
          oAll.value = "ALL";
          oAll.textContent = "Alle Sprachen";
          sel.appendChild(oAll);

          langs.forEach(l => {
            const o = document.createElement("option");
            o.value = l;
            o.textContent = l;
            sel.appendChild(o);
          });

          sel.value = temp;
          sel.onchange = () => { temp = sel.value; };

          wrap.appendChild(sel);
          body.appendChild(wrap);

          const note = document.createElement("div");
          note.className = "small";
          note.textContent = "Filter wirkt bei neuer Session.";
          body.appendChild(note);
        },
        () => { selectedLang = temp; updateLabels(); }
      );
    }

    function openDirectionModal() {
      let temp = direction;
      openModal(
        "Richtung",
        (body) => {
          $("modalGoBtn").disabled = false;
          $("modalGoBtn").textContent = "OK";
          const wrap = document.createElement("div");
          wrap.className = "field";
          wrap.innerHTML = `<label>Richtung ausw√§hlen</label>`;
          const sel = document.createElement("select");
          [
            ["DE_TO_FOREIGN","Deutsch ‚Üí Fremdsprache"],
            ["FOREIGN_TO_DE","Fremdsprache ‚Üí Deutsch"],
            ["BOTH","Beide Richtungen (gemischt)"]
          ].forEach(([v,t]) => {
            const o = document.createElement("option");
            o.value = v; o.textContent = t;
            sel.appendChild(o);
          });
          sel.value = temp;
          sel.onchange = () => { temp = sel.value; };
          wrap.appendChild(sel);
          body.appendChild(wrap);

        },
        () => { direction = temp; updateLabels(); }
      );
    }

    function openModeModal() {
      let temp = mode;
      openModal(
        "Modus",
        (body) => {
          $("modalGoBtn").disabled = false;
          $("modalGoBtn").textContent = "OK";
          const wrap = document.createElement("div");
          wrap.className = "field";
          wrap.innerHTML = `<label>Modus ausw√§hlen</label>`;
          const sel = document.createElement("select");
          [
            ["FLASH","Karteikarten (richtig/falsch)"],
            ["MCQ","Multiple Choice"],
            ["TYPE","Eingabe"]
          ].forEach(([v,t]) => {
            const o = document.createElement("option");
            o.value = v; o.textContent = t;
            sel.appendChild(o);
          });
          sel.value = temp;
          sel.onchange = () => { temp = sel.value; };
          wrap.appendChild(sel);
          body.appendChild(wrap);

          const note = document.createElement("div");
          note.className = "small";
          note.textContent = "Filter wirkt bei neuer Session.";
          body.appendChild(note);
        },
        () => { mode = temp; updateLabels(); syncOverlayButtons(); }
      );
    }

    function openLimitModal() {
      let temp = (limitN === 0) ? "0" : String(limitN);
    
      openModal(
        "Anzahl Fragen",
        (body) => {
          $("modalGoBtn").disabled = false;
          $("modalGoBtn").textContent = "OK";
          const wrap = document.createElement("div");
          wrap.className = "field";
          wrap.innerHTML = `<label>Anzahl ausw√§hlen</label>`;
    
          const sel = document.createElement("select");
          [
            ["0", "Unbegrenzt"],
            ["25", "25"],
            ["50", "50"],
            ["75", "75"],
            ["100", "100"]
          ].forEach(([v, t]) => {
            const o = document.createElement("option");
            o.value = v;
            o.textContent = t;
            sel.appendChild(o);
          });
    
          sel.value = temp;
          sel.onchange = () => { temp = sel.value; };
    
          wrap.appendChild(sel);
          body.appendChild(wrap);
    
          const note = document.createElement("div");
          note.className = "small";
          note.textContent = "Die Einstellung wirkt bei neuer Session.";
          body.appendChild(note);
        },
        () => {
          const n = Number(temp);
          limitN = (!Number.isFinite(n) || n <= 0) ? 0 : n;
          updateLabels();
        }
      );
    }

    function openLenientModal() {
      let temp = lenient;
      openModal(
        "Akzente & Gro√ü/klein ignorieren",
        (body) => {
          $("modalGoBtn").disabled = false;
          $("modalGoBtn").textContent = "OK";
          const wrap = document.createElement("div");
          wrap.className = "field";
          wrap.innerHTML = `<label>Gro√ü/Klein & Akzente ignorieren (nur Eingabe)</label>`;
          const sel = document.createElement("select");
          const o1 = document.createElement("option"); o1.value="OFF"; o1.textContent="aus";
          const o2 = document.createElement("option"); o2.value="ON"; o2.textContent="an";
          sel.appendChild(o1); sel.appendChild(o2);
          sel.value = temp ? "ON" : "OFF";
          sel.onchange = () => { temp = sel.value === "ON"; };
          wrap.appendChild(sel);
          body.appendChild(wrap);
          const expl = document.createElement("div");
          expl.className = "small";
          expl.innerHTML =
            "‚Ä¢ <span class=\"mono\">aus</span>: Deine Eingabe muss exakt passen.<br>" +
            "‚Ä¢ <span class=\"mono\">an</span>: Gro√ü/Klein und Akzente werden ignoriert (z.&nbsp;B. \"caf√©\" = \"Cafe\").";
          expl.style.marginTop = "8px";
          body.appendChild(expl);
        },
        () => { lenient = temp; updateLabels(); }
      );
    }

    function selectTagsByRecencyInSet(tagLatest, days, set) {
      const cutoff = new Date();
      cutoff.setDate(cutoff.getDate() - days);
      for (const [t, d] of tagLatest.entries()) {
        if ((d || new Date(0)) >= cutoff) set.add(t);
      }
    }

    function openTagsModal() {
      const tagLatest = computeTagRecency();
      const sortedTags = [...tagLatest.keys()].sort((a,b) => {
        const da = tagLatest.get(a) || new Date(0);
        const db = tagLatest.get(b) || new Date(0);
        if (db.getTime() !== da.getTime()) return db - da;  // neueste oben
        return a.localeCompare(b, "de");
      });

      // temp copy
      const temp = new Set(selectedTags);

      openModal(
        "Units/Tags",
        (body) => {
          $("modalGoBtn").disabled = false;
          $("modalGoBtn").textContent = "OK";
          const quick = document.createElement("div");
          quick.className = "row";
          quick.style.gap = "10px";
          quick.innerHTML = `
            <button id="t30">letzte 30 Tage</button>
            <button id="t90">letzte 90 Tage</button>
            <button id="tAll">alle</button>
            <button id="tNone">keine</button>
          `;
          body.appendChild(quick);

          const list = document.createElement("div");
          list.className = "tagList";

          function renderList() {
            list.innerHTML = "";
            sortedTags.forEach(t => {
              const d = tagLatest.get(t) || new Date(0);
              const row = document.createElement("div");
              row.className = "tagRow";

              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.checked = temp.has(t);
              cb.onchange = () => {
                if (cb.checked) temp.add(t);
                else temp.delete(t);
              };

              const name = document.createElement("div");
              name.className = "name";
              name.textContent = t;

              const date = document.createElement("div");
              date.className = "date";
              date.textContent = tagDateStr(d);

              row.appendChild(cb);
              row.appendChild(name);
              row.appendChild(date);

              row.addEventListener("click", (e) => {
                if (e.target === cb) return;
                cb.checked = !cb.checked;
                cb.dispatchEvent(new Event("change"));
              });

              list.appendChild(row);
            });
          }

          renderList();
          body.appendChild(list);

          // wire quick buttons
          $("t30").onclick = () => { temp.clear(); selectTagsByRecencyInSet(tagLatest, 30, temp); renderList(); };
          $("t90").onclick = () => { temp.clear(); selectTagsByRecencyInSet(tagLatest, 90, temp); renderList(); };
          $("tAll").onclick = () => { temp.clear(); sortedTags.forEach(t => temp.add(t)); renderList(); };
          $("tNone").onclick = () => { temp.clear(); renderList(); };

          const note = document.createElement("div");
          note.className = "small";
          note.textContent = "Sortierung: neueste Units oben (nach Added-Datum). Filter wirkt bei neuer Session.";
          body.appendChild(note);
        },
        () => { selectedTags = temp; updateLabels(); }
      );
    }

    function openLearnModal() {
      if (!vocab || vocab.length === 0) return;
    
      const tagLatest = computeTagRecency();
    
      // Alle Tags: neueste oben
      const sortedAll = [...tagLatest.keys()].sort((a,b) => {
        const da = tagLatest.get(a) || new Date(0);
        const db = tagLatest.get(b) || new Date(0);
        if (db.getTime() !== da.getTime()) return db - da;
        return a.localeCompare(b, "de");
      });
    
      // Auswahl unten im Modal (Checkbox-Liste)
      const temp = new Set();
    
      openModal(
        "Units/Tags ausw√§hlen",
        (body) => {
          $("modalGoBtn").textContent = "Los geht's";
          const syncGo = () => {
            $("modalGoBtn").disabled = temp.size === 0;
          };
          syncGo();

          const h = document.createElement("div");
          h.className = "sectionLbl";
          h.style.marginTop = "0";
          h.innerHTML = `<span class="mini">üè∑</span><span>Alle Units/Tags</span>`;
          body.appendChild(h);
    
          const list = document.createElement("div");
          list.className = "tagList";
    
          function renderList() {
            list.innerHTML = "";
            sortedAll.forEach(t => {
              const d = tagLatest.get(t) || new Date(0);
    
              const row = document.createElement("div");
              row.className = "tagRow";
    
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.checked = temp.has(t);
              cb.onchange = () => {
                if (cb.checked) temp.add(t);
                else temp.delete(t);
                syncGo();
              };
    
              const name = document.createElement("div");
              name.className = "name";
              name.textContent = t;
    
              const date = document.createElement("div");
              date.className = "date";
              date.textContent = tagDateStr(d);
    
              row.appendChild(cb);
              row.appendChild(name);
              row.appendChild(date);
    
              row.addEventListener("click", (e) => {
                if (e.target === cb) return;
                cb.checked = !cb.checked;
                cb.dispatchEvent(new Event("change"));
              });
    
              list.appendChild(row);
            });
          }
    
          renderList();
          body.appendChild(list);
    
          const note = document.createElement("div");
          note.className = "small";
          note.textContent = "Sortierung: neueste Units oben (nach Added-Datum).";
          body.appendChild(note);
    
          syncGo();
        },
        
          () => {
          // speichern & Card 3 aktualisieren
          saveRecentLearnTagsFromSet(temp);
          renderRecentLearnPills();
        
          // Lerntabelle √∂ffnen
          openLearnListModal(temp);
        }
      );
    }

    function openChallengeModal() {
      if (!vocab || vocab.length === 0) return;
    
      // Keine Challenge starten, wenn gerade gelernt wird
      if (inSession) return alert("Bitte beende zuerst die aktuelle Session.");
    
      const tagLatest = computeTagRecency();
    
      // Alle Tags: neueste oben
      const sortedAll = [...tagLatest.keys()].sort((a,b) => {
        const da = tagLatest.get(a) || new Date(0);
        const db = tagLatest.get(b) || new Date(0);
        if (db.getTime() !== da.getTime()) return db - da;
        return a.localeCompare(b, "de");
      });
    
      let chosenTag = "";
      let chosenTarget = 15; // Default (kannst du √§ndern)
    
      openModal(
        "Challenge starten",
        (body) => {
          $("modalGoBtn").textContent = "Los geht's";
          $("modalGoBtn").disabled = true;
    
          const syncGo = () => {
            $("modalGoBtn").disabled = !(chosenTag && Number(chosenTarget) > 0);
          };
    
          // Feld: Tag
          const tagWrap = document.createElement("div");
          tagWrap.className = "field";
          tagWrap.innerHTML = `<label>Unit/Tag</label>`;
          const tagSel = document.createElement("select");
    
          const opt0 = document.createElement("option");
          opt0.value = "";
          opt0.textContent = "Bitte ausw√§hlen ‚Ä¶";
          tagSel.appendChild(opt0);
    
          sortedAll.forEach(t => {
            const o = document.createElement("option");
            o.value = t;
            o.textContent = `${t}  (${tagDateStr(tagLatest.get(t))})`;
            tagSel.appendChild(o);
          });
    
          tagSel.value = chosenTag;
          tagSel.onchange = () => {
            chosenTag = tagSel.value;
            syncGo();
          };
    
          tagWrap.appendChild(tagSel);
          body.appendChild(tagWrap);
    
          // Feld: Ziel
          const targetWrap = document.createElement("div");
          targetWrap.className = "field";
          targetWrap.innerHTML = `<label>Ziel (Anzahl Vokabeln)</label>`;
          const targetSel = document.createElement("select");
    
          [
            [10, "10"],
            [15, "15"],
            [25, "25"],
            [50, "50"]
          ].forEach(([v, txt]) => {
            const o = document.createElement("option");
            o.value = String(v);
            o.textContent = txt;
            targetSel.appendChild(o);
          });
    
          targetSel.value = String(chosenTarget);
          targetSel.onchange = () => {
            const n = Number(targetSel.value);
            chosenTarget = Number.isFinite(n) ? n : 15;
            syncGo();
          };
    
          targetWrap.appendChild(targetSel);
          body.appendChild(targetWrap);
    
          const note = document.createElement("div");
          note.className = "small";
          note.style.marginTop = "6px";
          note.textContent = "Hinweis: Wird die Challenge abgebrochen, wird sie nicht gespeichert.";
          body.appendChild(note);
    
          syncGo();
        },
        () => {
          // OK: Challenge starten + Lern-Overlay √∂ffnen
          const ok = startChallenge(chosenTag, chosenTarget);
          if (!ok) return alert("Challenge konnte nicht gestartet werden.");
    
          // F√ºr Challenges: wir erzwingen eine Session auf diesem Tag
          selectedTags = new Set([chosenTag]);
          updateLabels();
    
          const built = buildSession();
          if (!built) {
            // Wenn keine Vokabeln im Tag: Challenge wieder weg
            inChallenge = false;
            if (APP_STATE) {
              APP_STATE.activeChallenge = null;
              saveRootState(APP_STATE);
            }
            return alert("Keine passenden Vokabeln f√ºr diese Unit/Tag.");
          }
    
          inSession = true;
          openOverlay();
        }
      );
    }

    
    // -------------------------
    // Card 3: Zuletzt gelernt
    // -------------------------
    function loadRecentLearnTags() {
      try {
        const raw = localStorage.getItem(LS_LEARN_TAGS_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr.filter(Boolean) : [];
      } catch {
        return [];
      }
    }
    
    function renderRecentLearnPills() {
      const host = $("recentLearnTags");
      const btn = $("learnStartBtn");
      if (!host) return;
    
      host.innerHTML = "";
    
      const recent = loadRecentLearnTags().slice(0, 3);
    
      // Button erst aktivieren, wenn CSV da ist
      if (btn) btn.disabled = (vocab.length === 0);
    
      if (recent.length === 0) {
        const div = document.createElement("div");
        div.className = "small";
        div.textContent = "Noch nichts gespeichert.";
        host.appendChild(div);
        return;
      }
    
      recent.forEach(t => {
        const b = document.createElement("button");
        b.className = "learnPillBtn";
        b.textContent = t;
    
        // Platzhalter ‚Äì echte Funktion kommt sp√§ter
        b.onclick = () => {
          // Klick z√§hlt als "neueste Auswahl"
          saveRecentLearnTagsFromSet(new Set([t]));
          renderRecentLearnPills();
          openLearnListModal(new Set([t]));
        };
    
        host.appendChild(b);
      });
    }
    
    function saveRecentLearnTagsFromSet(tagSet) {
      const chosen = [...tagSet].filter(Boolean);
      if (chosen.length === 0) return;
    
      const current = loadRecentLearnTags();
    
      const next = [];
      for (const t of chosen) if (!next.includes(t)) next.push(t);
      for (const t of current) if (!next.includes(t)) next.push(t);
    
      localStorage.setItem(LS_LEARN_TAGS_KEY, JSON.stringify(next.slice(0, 10)));
    }

    function openLearnListModal(tagSet) {
      if (!vocab || vocab.length === 0) return;
    
      const tags = new Set([...tagSet].filter(Boolean));
      if (tags.size === 0) return;
    
      let pool = vocab.filter(v =>
        parseTags(v.tags).some(t => tags.has(t))
      );
    
      openModal(
        "Lerntabelle (Fremdsprache ‚Üí Deutsch)",
        (body) => {
          if ($("modalGoBtn")) {
            $("modalGoBtn").disabled = false;   // ‚úÖ klickbar
            $("modalGoBtn").textContent = "OK"; // ‚úÖ Beschriftung
          }
          if ($("modalCancelBtn")) $("modalCancelBtn").style.display = "none"; // ‚úÖ nur OK sichtbar

          const sel = document.createElement("div");
          sel.className = "small";
          sel.innerHTML = `Auswahl: <span class="mono">${[...tags].join(" ¬∑ ")}</span>`;
          body.appendChild(sel);
    
          const cnt = document.createElement("div");
          cnt.className = "small";
          cnt.textContent = `${pool.length} Vokabeln`;
          body.appendChild(cnt);
    
          const list = document.createElement("div");
          list.className = "learnList";
    
          if (pool.length === 0) {
            const empty = document.createElement("div");
            empty.className = "small";
            empty.textContent = "Keine passenden Vokabeln.";
            body.appendChild(empty);
            return;
          }
    
          for (const it of pool) {
            const row = document.createElement("div");
            row.className = "learnRow";
    
            const f = document.createElement("div");
            f.className = "f";
            f.textContent = it.foreign || "‚Äî";
    
            const d = document.createElement("div");
            d.className = "d";
            d.textContent = it.de || "‚Äî";
    
            const ex = document.createElement("div");
            ex.className = "ex";
            const example = (it.example || "").trim();
            ex.textContent = example ? example : ""; // wenn leer: einfach nichts
            
            row.appendChild(f);
            row.appendChild(d);
            if (example) row.appendChild(ex);
    
            list.appendChild(row);
          }
    
          body.appendChild(list);
        },
        null
      );
    }

    // -------------------------
    // Wiring
    // -------------------------
    $("nextBtn2").addEventListener("click", next);
    $("endBtn2").addEventListener("click", endSession);

    $("startBtn").addEventListener("click", () => {
      if (vocab.length === 0) return alert("Keine Vokabeln vorhanden.");
      const ok = buildSession();
      if (!ok) return alert("Keine passenden Vokabeln f√ºr deine Filter (Sprache/Tags).");
      inSession = true;
      openOverlay();
    });

    $("challengeStartBtn").addEventListener("click", openChallengeModal); 
    
    // -------------------------
    // Auto-Reload beim Zur√ºckkommen (nur wenn keine Session/Challenge l√§uft)
    // -------------------------
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState !== "visible") return;
    
      if (!APP_STATE) return;
    
      // W√§hrend aktiver Session/Challenge NICHT reloaden / kein Popup
      if (inSession || inChallenge) {
        console.log("[visibilitychange] skip reload (active):", { inSession, inChallenge });
        return;
      }
    
      // 1) erst reloaden (CSV+State sync)
      reloadCsvAndSyncState("visibilitychange-visible").then(() => {
        // 2) danach ggf. Streak-Popup zeigen (falls heute f√§llig)
        maybeShowStreakPopupIfDue("visibilitychange-visible");
      });
    });

    $("modal").addEventListener("click", (e) => {
      if (e.target === $("modal")) closeModal("cancel");
    });
    
    // Open modals
    $("pickLang").addEventListener("click", openLangModal);
    $("pickDirection").addEventListener("click", openDirectionModal);
    $("pickMode").addEventListener("click", openModeModal);
    $("pickLimit").addEventListener("click", openLimitModal);
    $("pickLenient").addEventListener("click", openLenientModal);
    $("pickTags").addEventListener("click", openTagsModal);
    $("learnStartBtn").addEventListener("click", openLearnModal);
    $("modalCancelBtn").addEventListener("click", () => closeModal("cancel"));
    $("modalGoBtn").addEventListener("click", () => closeModal("ok"));

    async function loadCsvAndBuildVocab() {
      const r = await fetch(CSV_URL, { cache: "no-store" });
      if (!r.ok) throw new Error("CSV not found");
      const text = await r.text();
      const items = fromCsv(text);
    
      const vocab = items
        .filter(it => (it.de || it.foreign) && (it.lang || "").trim())
        .map(it => ({
          id: (it.id || "").toString().trim(),
          added: (it.added || "").trim(),
          de: (it.de || "").trim(),
          foreign: (it.foreign || "").trim(),
          lang: (it.lang || "EN").toUpperCase().trim(),
          tags: (it.tags || "").trim(),
          example: (it.example || "").trim()
        }))
        .filter(it => it.id && it.de && it.foreign);
    
      return vocab;
    }
    
    // -------------------------
    // CSV RELOAD + STATE SYNC
    // -------------------------
    async function reloadCsvAndSyncState(reason = "") {
      try {
        console.log("[reload] start:", reason);
    
        // 1) CSV neu laden
        vocab = await loadCsvAndBuildVocab();
    
        // 2) State mit neuen Vokabeln synchronisieren
        ensureVocabStatesFromCsv(APP_STATE, vocab);
    
        // 3) Decay pro ID
        for (const it of vocab) {
          applyDecayIfNeededForId(it.id);
        }
    
        // 4) Persistieren
        saveRootState(APP_STATE);
    
        // 5) UI aktualisieren
        renderCsvTable();
        renderRecentLearnPills();
        updateLabels();
    
        // Buttons neu setzen
        $("startBtn").disabled = vocab.length === 0;
        if ($("learnStartBtn")) $("learnStartBtn").disabled = vocab.length === 0;
    
        console.log("[reload] done:", reason, "items:", vocab.length);
    
        // Optional: wenn nach Reload ein Streak-Popup f√§llig ist (und idle), zeig es.
        // (Das ist genau dein Wunsch "bei Reload / visibilityreturn")
        if (!inSession && !inChallenge && APP_STATE) {
          maybeShowStreakPopupIfDue("reload-" + reason);
        }
    
        return true;
      } catch (e) {
        console.error("[reload] failed:", reason, e);
        return false;
      }
    }
    
    // -------------------------
    // INIT
    // -------------------------
    async function init() {
      $("csvLabel").textContent = CSV_URL;
      $("startBtn").disabled = true;
      $("challengeStartBtn").disabled = true;
      updateLabels();

      try {
        vocab = await loadCsvAndBuildVocab();
        const hasVocab = vocab.length > 0;

        APP_STATE = loadRootState();
        inChallenge = !!(APP_STATE.activeChallenge && !APP_STATE.activeChallenge.finishedAt);
          // daily entries sanieren
        if (APP_STATE?.prefs?.daily && typeof APP_STATE.prefs.daily === "object") {
          for (const k of Object.keys(APP_STATE.prefs.daily)) {
            const e = APP_STATE.prefs.daily[k];
            if (!e || typeof e !== "object") {
              APP_STATE.prefs.daily[k] = { uniqueIds: [] };
            } else if (!Array.isArray(e.uniqueIds)) {
              APP_STATE.prefs.daily[k].uniqueIds = [];
            }
          }
        }
        ensureVocabStatesFromCsv(APP_STATE, vocab);
        for (const it of vocab) {
          applyDecayIfNeededForId(it.id);
        }
        saveRootState(APP_STATE);
          
        renderCsvTable();

        const searchEl = $("vocabSearch");
        if (searchEl) {
          searchEl.value = "";
          searchEl.oninput = () => {
            vocabSearchQuery = searchEl.value || "";
            renderCsvTable();
          };
        }
          
        $("startBtn").disabled = vocab.length === 0;

        // Card 3 aktivieren, sobald CSV geladen ist
        $("learnStartBtn").disabled = vocab.length === 0;
        $("challengeStartBtn").disabled = !hasVocab;
        renderRecentLearnPills();
        renderChallengeHistory();
          
        updateLabels();
      } catch (e) {
        vocab = [];
        renderCsvTable();
        updateLabels();
        $("startBtn").disabled = true;
        if ($("learnStartBtn")) $("learnStartBtn").disabled = true;
        renderRecentLearnPills();
        renderChallengeHistory(); 
      }
    }

    init();
  </script>
</body>
</html>
